---
title: 并发基础
date: 2019-09-03 16:00:35
tags:
    - java
    - 并发
---

# 1. 进程
## 1. 进程与线程
![进程与线程的比较](https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20190903180002.png)

## 2. 进程调度算法
- 批处理系统
    - 先来先服务
    - 短作业优先
    - 最短剩余时间优先

- 交互式系统
    - 时间片轮转
    - 优先级调度
    - 多级反馈队列

- 实时系统

## 3. 进程间同步
![进程间同步](https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20190915170015.png)

## 4. 进程间通信
![进程间通信](https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20190915170835.png)

# 2. 线程
## 1. 线程的状态
![线程的5种状态](https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20190915171216.png)
- 创建
- 就绪态
- 运行态
- 阻塞态
- 终止

就绪态 <-> 运行态：

就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。

运行态 -> 阻塞态 -> 就绪态：

IO等待，或者手动调用 wait 或者 join 函数；

等待结束，或者notify, notify all.

## 2. 实现多线程的方式
- 实现 Runnable接口
- 实现 Callable接口
- 继承 Thread
- Executor


# 3.安全
## 1. java内存模型

- 原子性：使用synchronized 和 lock实现

- 可见性：利用 volatile实现

- 有序性：利用 happen-before原则实现

## 2. 线程安全
- 不可变：final, String, 枚举类型， Number

- 阻塞同步（悲观锁）：synchronized, ReentranLock

- 非阻塞同步（乐观锁）：乐观锁（CAS锁）

- 无同步方案：栈封闭（局部变量）； 单线程； 可重入 

## 3. 关键词
- volatile: 
    - 可见性
    - 禁止指令重排

- Synchronized:

    修饰
    - 类： 锁类的所有对象
    - 静态方法： 锁调用这个方法的所有对象
    - 代码块： 锁调用这个方法块的对象
    - 方法： 锁调用这个方法的对象

- ReentranLock:
    - 可重入
    - condition
    - 公平、非公平

## 4. 锁
- 公平锁/非公平锁: 多个线程获取锁的顺序是/不是按照申请锁的顺序

- 可重入锁： 又叫递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁
    - ReentrantLock
    - Synchronized

- 独享锁/共享锁：
    - 独享锁是指该锁一次只能被一个线程所持有。ReentrantLock，Synchronized
    - 共享锁是指该锁可被多个线程所持有。ReadWriteLock

- 互斥锁/读写锁：


- 乐观锁/悲观锁：
    - 悲观锁适合写操作非常多的场景，悲观锁在Java中的使用，就是利用各种锁。
    - 乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。

- 分段锁 (细化锁的粒度)

    分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。
    当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。
    但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。

    分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。

- 偏向锁/轻量级锁/重量级锁: 这三种锁是指锁的状态，并且是针对Synchronized

    - 偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。
    - 轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
    - 重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。

- 自旋锁

    在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。


# 4. 并发包：java.util.concurrent
